{
  "version": 3,
  "sources": ["../../src/lib/messageHandlers.ts"],
  "sourcesContent": ["import type { SpreadsheetUtils } from './google';\nimport fs from 'fs';\n\n/**\n * Handles appending data to a spreadsheet sheet.\n *\n * @param spreadsheet Instance of SpreadsheetUtils\n * @param log ioBroker Logger\n * @param message Message object with sheetName, data and optional alias\n * @returns Promise that resolves on success\n */\nexport function handleAppend(\n    spreadsheet: SpreadsheetUtils,\n    log: ioBroker.Logger,\n    message: Record<string, any>,\n): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n        const messageData: Record<string, any> = message.message as Record<string, any>;\n        if (missingParameters(['sheetName', 'data'], messageData, log)) {\n            reject(new Error('Missing parameters for append'));\n        }\n        spreadsheet\n            .append(messageData.sheetName, messageData.data, messageData.alias)\n            .then(() => resolve())\n            .catch(error => reject(new Error(error)));\n    });\n}\n\n/**\n * Handles deleting rows in a spreadsheet sheet.\n *\n * @param spreadsheet Instance of SpreadsheetUtils\n * @param log ioBroker Logger\n * @param message Message object with sheetName, start, end and optional alias\n * @returns Promise that resolves on success\n */\nexport function handleDeleteRows(\n    spreadsheet: SpreadsheetUtils,\n    log: ioBroker.Logger,\n    message: Record<string, any>,\n): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n        const messageData: Record<string, any> = message.message as Record<string, any>;\n        if (missingParameters(['sheetName', 'start', 'end'], messageData, log)) {\n            reject(new Error('Missing parameters for deleteRows'));\n        }\n        spreadsheet\n            .deleteRows(messageData.sheetName, messageData.start, messageData.end, messageData.alias)\n            .then(() => resolve())\n            .catch(error => reject(new Error(error)));\n    });\n}\n\n/**\n * Handles creating a new spreadsheet sheet.\n *\n * @param spreadsheet Instance of SpreadsheetUtils\n * @param log ioBroker Logger\n * @param message Message object with sheetName and optional alias\n * @returns Promise that resolves on success\n */\nexport function handleCreateSheet(\n    spreadsheet: SpreadsheetUtils,\n    log: ioBroker.Logger,\n    message: Record<string, any>,\n): Promise<void> {\n    if (typeof message.message === 'string') {\n        log.warn(\n            'Deprecated call of createSheet with string as message. Please use object with sheetName and optional alias!',\n        );\n        return spreadsheet.createSheet(message.message, null);\n    }\n    const messageData: Record<string, any> = message.message as Record<string, any>;\n    if (missingParameters(['sheetName'], messageData, log)) {\n        return Promise.reject(new Error('Missing parameters for createSheet'));\n    }\n    return spreadsheet.createSheet(messageData.sheetName as string, messageData.alias);\n}\n\n/**\n * Handles deleting a spreadsheet sheet.\n *\n * @param spreadsheet Instance of SpreadsheetUtils\n * @param log ioBroker Logger\n * @param message Message object with sheetName and optional alias\n * @returns Promise that resolves on success\n */\nexport function handleDeleteSheet(\n    spreadsheet: SpreadsheetUtils,\n    log: ioBroker.Logger,\n    message: Record<string, any>,\n): Promise<void> {\n    if (typeof message.message === 'string') {\n        log.warn(\n            'Deprecated call of deleteSheet with non-string as message. Please use object with sheetName and optional alias!',\n        );\n        return spreadsheet.deleteSheet(message.message);\n    }\n    const messageData: Record<string, any> = message.message as Record<string, any>;\n    if (missingParameters(['sheetName'], messageData, log)) {\n        return Promise.reject(new Error('Missing parameters for deleteSheet'));\n    }\n    return spreadsheet.deleteSheet(messageData.sheetName as string, messageData.alias);\n}\n\n/**\n * Handles deleting multiple spreadsheet sheets.\n *\n * @param spreadsheet Instance of SpreadsheetUtils\n * @param log ioBroker Logger\n * @param message Message object with sheetNames (array) and optional alias\n * @returns Promise that resolves on success\n */\nexport function handleDeleteSheets(\n    spreadsheet: SpreadsheetUtils,\n    log: ioBroker.Logger,\n    message: Record<string, any>,\n): Promise<void> {\n    if (Array.isArray(message.message)) {\n        log.warn(\n            'Deprecated call of deleteSheets with array as message. Please use object with sheetNames and optional alias!',\n        );\n        return spreadsheet.deleteSheets(message.message as string[], null);\n    }\n    const messageData: Record<string, any> = message.message as Record<string, any>;\n    if (missingParameters(['sheetNames'], messageData, log)) {\n        return Promise.reject(new Error('Missing parameters for deleteSheets'));\n    }\n    return spreadsheet.deleteSheets(messageData.sheetNames as string[], messageData.alias);\n}\n\n/**\n * Handles duplicating a spreadsheet sheet.\n *\n * @param spreadsheet Instance of SpreadsheetUtils\n * @param log ioBroker Logger\n * @param message Message object with source, target, index and optional alias\n * @returns Promise that resolves on success\n */\nexport function handleDuplicateSheet(\n    spreadsheet: SpreadsheetUtils,\n    log: ioBroker.Logger,\n    message: Record<string, any>,\n): Promise<void> {\n    const messageData: Record<string, any> = message.message as Record<string, any>;\n    if (missingParameters(['source', 'target', 'index'], messageData, log)) {\n        return Promise.reject(new Error('Missing parameters for duplicateSheet'));\n    }\n    return spreadsheet.duplicateSheet(messageData.source, messageData.target, messageData.index, messageData.alias);\n}\n\n/**\n * Handles uploading a file to a Google Drive folder.\n *\n * @param spreadsheet Instance of SpreadsheetUtils\n * @param log ioBroker Logger\n * @param message Message object with target, parentFolder and source\n * @returns Promise that resolves on success\n */\nexport function handleUpload(\n    spreadsheet: SpreadsheetUtils,\n    log: ioBroker.Logger,\n    message: Record<string, any>,\n): Promise<void> {\n    const messageData: Record<string, any> = message.message as Record<string, any>;\n    if (missingParameters(['target', 'parentFolder'], messageData, log)) {\n        return Promise.reject(new Error('Missing parameters for upload'));\n    }\n    return spreadsheet.upload(messageData.target, messageData.parentFolder, fs.createReadStream(messageData.source));\n}\n\n/**\n * Handles writing to a single cell of a spreadsheet sheet.\n *\n * @param spreadsheet Instance of SpreadsheetUtils\n * @param log ioBroker Logger\n * @param message Message object with sheetName, cell, data and optional alias\n * @returns Promise that resolves on success\n */\nexport function handleWriteCell(\n    spreadsheet: SpreadsheetUtils,\n    log: ioBroker.Logger,\n    message: Record<string, any>,\n): Promise<void> {\n    const messageData: Record<string, any> = message.message as Record<string, any>;\n    if (missingParameters(['sheetName', 'cell', 'data'], messageData, log)) {\n        return Promise.reject(new Error('Missing parameters for writeCell'));\n    }\n    const cellPattern = new RegExp('[A-Z]+[0-9]+()');\n    if (!cellPattern.test(messageData.cell)) {\n        log.error(`Invalid cell pattern ${messageData.cell}. Expected: A1`);\n        return Promise.reject(new Error(`Invalid cell pattern ${messageData.cell}. Expected: A1`));\n    }\n    return spreadsheet.writeCell(messageData.sheetName, messageData.cell, messageData.data, messageData.alias);\n}\n\n/**\n * Handles writing to multiple cells of one or more spreadsheet sheets.\n *\n * @param spreadsheet Instance of SpreadsheetUtils\n * @param log ioBroker Logger\n * @param message Message object with cells (array) and optional alias\n * @returns Promise that resolves on success\n */\nexport function handleWriteCells(\n    spreadsheet: SpreadsheetUtils,\n    log: ioBroker.Logger,\n    message: Record<string, any>,\n): Promise<void> {\n    const messageData: Record<string, any> = message.message as Record<string, any>;\n    if (missingParameters(['cells'], messageData, log)) {\n        return Promise.reject(new Error('Missing parameters for writeCells'));\n    }\n    const cells: Array<{ sheetName: string; cell: string; data: any }> = messageData.cells as Array<{\n        sheetName: string;\n        cell: string;\n        data: any;\n    }>;\n    const cellPattern = new RegExp('[A-Z]+[0-9]+()');\n    for (const cellObj of cells) {\n        if (!cellPattern.test(cellObj.cell)) {\n            log.error(`Invalid cell pattern ${cellObj.cell}. Expected: A1`);\n            return Promise.reject(new Error(`Invalid cell pattern ${cellObj.cell}. Expected: A1`));\n        }\n    }\n    return spreadsheet.writeCells(cells, messageData.alias);\n}\n\n/**\n * Handles reading a single cell of a spreadsheet sheet.\n *\n * @param spreadsheet Instance of SpreadsheetUtils\n * @param log ioBroker Logger\n * @param message Message object with sheetName, cell and optional alias\n * @returns Promise that resolves with the read value\n */\nexport function handleReadCell(\n    spreadsheet: SpreadsheetUtils,\n    log: ioBroker.Logger,\n    message: Record<string, any>,\n): Promise<any> {\n    const messageData: Record<string, any> = message.message as Record<string, any>;\n    if (missingParameters(['sheetName', 'cell'], messageData, log)) {\n        return Promise.reject(new Error('Missing parameters for readCell'));\n    }\n    const cellPattern = new RegExp('[A-Z]+[0-9]+()');\n    if (!cellPattern.test(messageData.cell)) {\n        log.error(`Invalid cell pattern ${messageData.cell}. Expected: A1`);\n        return Promise.reject(new Error(`Invalid cell pattern ${messageData.cell}. Expected: A1`));\n    }\n    return spreadsheet.readCell(messageData.sheetName, messageData.cell, messageData.alias);\n}\n\nfunction missingParameters(\n    neededParameters: string[],\n    messageData: Record<string, any>,\n    log: ioBroker.Logger,\n): boolean {\n    let result = false;\n    for (const parameter of neededParameters) {\n        if (Object.keys(messageData).indexOf(parameter) == -1) {\n            result = true;\n            log.error(`The parameter '${parameter}' is required but was not passed!`);\n        }\n    }\n    return result;\n}\n"],
  "mappings": "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",
  "names": ["fs"]
}
